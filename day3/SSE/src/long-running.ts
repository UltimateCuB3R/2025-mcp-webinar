import express from "express";
import logger from "./logging.js";

const router = express.Router();

router.post("/regular", async (_, response) => {
  logger.info("Received regular request, simulating long running op");

  try {
    // The following sleep line simulates a long running, async operation
    // (e.g. a call to AI, a database query, a service call, etc.)
    await sleep(2000);

    logger.info("Long running op complete");
    response.send("Done");
  } catch (error) {
    logger.error({ error }, "Error in regular request");
    if (!response.headersSent) {
      response.status(500).send("Internal Server Error");
    }
  }
});

router.post("/streaming", async (_, response) => {
  // Here we simulate a requirement where the server has to gather
  // data step-by-step through multiple long running, async operations. 
  // This could be due to the data being generated by e.g. an AI 
  // in streaming mode (https://platform.openai.com/docs/api-reference/streaming). 
  // The client can start processing the data as soon as it arrives, 
  // instead of waiting for the full result.

  logger.info("Received streaming request");

  let aborted = false;
  const cleanup = () => {
    aborted = true;
    if (!response.writableEnded) {
      response.end();
    }
  };

  response.on('close', () => {
    logger.info("Client disconnected from streaming request");
    cleanup();
  });

  try {
    response.writeHead(200, { "Content-Type": "text/plain" });

    for (let i = 0; i < 10; i++) {
      if (aborted) break;

      logger.info(`Getting chunk ${i}`);

      // The following sleep line simulates a long running, async operation
      // (e.g. a call to AI, a database query, a service call, etc.)
      await sleep(1000);

      if (aborted) break;

      response.write(`Data ${i}\n`);
      // Note that we ignore the return value of response.write as
      // we send rather small amounts of data. For larger amounts,
      // add handling of the return value and drain event.
    }

    logger.info("Streaming complete");
    response.end();
  } catch (error) {
    logger.error({ error }, "Error in streaming request");
    cleanup();
  }
});

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export default router;
